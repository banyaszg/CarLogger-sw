/*
 * Project CarLogger
 * Description:
 * Author:
 * Date:
 */

#if PLATFORM_ID == 10 // Electron
  #define SEC_CAN
#elif PLATFORM_ID == 6 // Photon
#else
  #error "This library only works on the Electron and Photon"
#endif

//SYSTEM_MODE(SEMI_AUTOMATIC);
SYSTEM_THREAD(ENABLED);

#include "SdFat.h"

// Primary SPI with DMA
// SCK => A3, MISO => A4, MOSI => A5, SS => A2 (default)
SdFat sd;
const uint8_t chipSelect = SS;

File logFile;
uint8_t logSyncCnt;
#define LOGSYNC 16

CANChannel can1(CAN_D1_D2);
#ifdef SEC_CAN
CANChannel can2(CAN_C4_C5);
#endif

const char SLCAN_NL = '\r';
const char SLCAN_ACK = '\r';
const char SLCAN_NACK = '\a';
// SLCAN_CMD_LEN sizeof("T12345678811223344556677881234\r")+1
#define SLCAN_CMD_LEN 32
bool slcanTSEn = false;

void logMessage(int ix, const CANMessage &message);
void printMessage(const CANMessage &message);
void parseSlcanCmd(char* buf);

void reset_handler()
{
  can1.end();
  #ifdef SEC_CAN
  can2.end();
  #endif
  logFile.close();
}

// setup() runs once, when the device is first turned on.
void setup()
{
  Serial.begin(1000000);
  pinMode(D7, OUTPUT);

  logSyncCnt = 0;
  if(sd.begin(chipSelect, SPI_FULL_SPEED)) {
    for(int i = 0; i < 1000; i++) {
      String fname = String::format("can%03d.log", i);
      if(logFile.open(fname,  O_CREAT | O_EXCL | O_WRONLY)) {
        break;
      }
    }
  }
  if(logFile.isOpen()) {
    logFile.printf("# Log file generated by CanLogger\n");
    logFile.sync();
  }

  can1.begin(500000);
  #ifdef SEC_CAN
  can2.begin(125000);
  #endif

  // register the reset handler
  System.on(reset, reset_handler);
}

// loop() runs over and over again, as quickly as it can execute.
void loop()
{
  // Recv CAN
  if(can1.isEnabled()) {
    CANMessage message1;
    if(can1.receive(message1)) {
      logMessage(0, message1);

      printMessage(message1);
    }
  }
  #ifdef SEC_CAN
  if(can2.isEnabled()) {
    CANMessage message2;
    if(can2.receive(message2)) {
      logMessage(1, message2);

      /* HACK: CAN over Serial protocol supports only 1 CAN bus
       * We merge in the CAN2 communication and the bit10 in the ID indicates it.
       */
      message2.id |= 0x400;
      printMessage(message2);
    }
  }
  #endif

  // Sync SD
  if(logSyncCnt >= LOGSYNC) {
    logSyncCnt = 0;
    digitalWrite(D7, HIGH);
    logFile.sync();
  }
}

void logMessage(int ix, const CANMessage &message)
{
  logFile.printf("(%010lu.%06lu) can%d %03x#", millis() / 1000, micros() % 1000000, ix, message.id);
  for(auto i = 0; i < message.len; i++) {
    logFile.printf("%02x", message.data[i]);
  }
  logFile.printf("\n");

  logSyncCnt++;
  digitalWrite(D7, LOW);
}

void printMessage(const CANMessage &msg)
{
  if(msg.extended) {
    if(msg.rtr) {
      Serial.printf("R%08X%01d", msg.id, msg.len);
    } else {
      Serial.printf("T%08X%01d", msg.id, msg.len);
    }
  } else {
    if(msg.rtr) {
      Serial.printf("r%03X%01d", msg.id, msg.len);
    } else {
      Serial.printf("t%03X%01d", msg.id, msg.len);
    }
  }
  for(auto i = 0; i < msg.len; i++) {
    Serial.printf("%02X", msg.data[i]);
  }

  // Timestamp
  if(slcanTSEn) {
    Serial.printf("%04X", millis() % 60000);
  }

  Serial.write(SLCAN_NL);
}

void slcan_ack()
{
  Serial.write(SLCAN_ACK); // ACK
}

void slcan_nack()
{
  Serial.write(SLCAN_NACK); // NACK
}

void serialEvent()
{
  int len;
  static char cmdbuf[SLCAN_CMD_LEN];
  static int cmdidx = 0;
  char c;

  if((len = Serial.available()) > 0) {
    for(int i = 0; i < len; i++) {
      c = Serial.read();
      cmdbuf[cmdidx++] = c;

      if (cmdidx == SLCAN_CMD_LEN) {
        // Too long
        slcan_nack();
        cmdidx = 0;
      } else if (c == SLCAN_NL) {
        // Command packet
        cmdbuf[cmdidx] = '\0';
        parseSlcanCmd(cmdbuf);
        cmdidx = 0;
      }
    }
  }
}

void parseSlcanCmd(char* buf)
{
  switch(buf[0])
  {
    case 'S': // Setup with standard CAN bit-rates where n is 0-8.
      // unused
      slcan_ack();
      break;
    case 's': // direct bitrate register
      slcan_nack();
      break;
    case 'O': // Open the CAN channel.
      // unused
      slcan_ack();
      break;
    case 'C': // Close the CAN channel.
      // unused
      slcan_ack();
      break;
    case 't': // Transmit a standard (11bit) CAN frame.
    case 'T': // Transmit an extended (29bit) CAN frame.
    case 'r': // Transmit an standard RTR (11bit) CAN frame.
    case 'R': // Transmit an extended RTR (29bit) CAN frame.
      // unused
      slcan_ack();
      break;
    case 'F': // Read Status Flags.
      Serial.print("F00");
      slcan_ack();
      break;
    case 'M': // Acceptance Code (SJA1000)
      slcan_ack();
      break;
    case 'm': //  Acceptance Mask (SJA1000)
      slcan_ack();
      break;
    case 'V': // Version
      Serial.print("V0001");
      slcan_ack();
      break;
    case 'N': // Serial number
      Serial.print("N0001");
      slcan_ack();
      break;
    case 'Z': // Sets Time Stamp ON/OFF
      if(buf[1] == '0') {
        slcanTSEn = false;
      } else if (buf[1] == '1') {
        slcanTSEn = true;
      } else {
        slcan_nack();
      }
      slcan_ack();
      break;
    default: // unknown command
      slcan_nack();
      break;
  }
}
